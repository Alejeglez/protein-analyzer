# protein-analyzer
Para este caso práctico, he desarrollado 2 archivos de código. En el primero, llamado protein-analyzer.py, he usado el concepto de k-mers (similar a los n-gramas de PLN) para calcular los segmentos de aminoácidos de tamaño k=3 que están en una secuencia de proteínas. Antes de poder crear estas secuencias de k-mers, los datos han sido leídos usando la librería de BioPython, que incluye herrameintas para leer secuencias de archivos fasta. De esta librería hemos sacado también las etiquetas de las proteínas, aunque la clasificación no ha tenido un gran resultado. Los datos usados son los de las proteínas que se encontraban junto con la tarea. Se han filtrado alas secuencias para quedarnos con aquellas que tengan una longitud de aminoácidos mayor a 3.

Una vez obtenemos la secuencia de k-mers para una secuencia de aimnoácidos, calculamos el tf-idf de cada aminoácido en dicha secuencia. El método tf-idf (Term Frequency-Inverse Document Frequency), en el campo de PLN determina la importancia de una palabra dentro de un documento del corpus. Es decir, cuanto mayor sea el valor de tf-idf, significa que ese k-mer es muy relevante en esa secuencia de aminoácidos, debido a que en el resto de secuencias no está presente. Para ello, usamos la librería sklearn, que ya tiene su propio método TfidfVectorizer. Esta función transforma nuestra lista de kmers para cada secuencia, en valores númericos.

En el siguiente artículo científico [A survey of k-mer methods and applications in bioinformatics](https://www.sciencedirect.com/science/article/pii/S2001037024001703) se debate el uso de k-mers en los campos de la genómica y proteinómica. En él se destacan la capacidad para detectar fragmentos faltantes, mutaciones, o realizar un análisis de estos fragmentos en genomas. También pueden ser de ayuda para detectar proteínas homólogas. Esta parte la enmarcaría en preprocesamiento de datos.

Una vez tenemos calculado el vector tf-idf para cada secuencia, podemos calcular la similitud coseno para obtener las secuencias más similares. Sklearn incluye también una función dedicada a este apartado (cosine_similarity). Si lo deseamos podemos ver los resultados en un mapa de calor. Los valores con mayor similitud, han sido aquellos que compartían secuencia de aminoácidos. Esta parte encajaría dentro del apartado de Visualización y análisis de patrones. 

Por último, se ha intentado realizar una clasificación usando un SVM en el archivo protein-classifier.py. Sklearn incluye las funciones necesarias para ello. Sin embargo los resultados no han sido muy buenos, una de mis posibles explicaciones es que el conjunto de entrenamiento tiene una variabilidad de proteínas grande en relación a su tamaño. Sin embargo, algunos estudios [A robust protein language model for SARS-CoV-2 protein–protein interaction network prediction](https://www.sciencedirect.com/science/article/pii/S093336572300088X) han conseguido grandes resultados usando este enfoque. En el ejemplo citado, se consigue un accuracy de un 98.6% usando SVM con vectores de tf-idf de 4-mers, sin embargo han usado conjuntos de datos enormes para poder llegar a este resultado, lo cúal no podría ser un punto tan positivo dado al costo del etiquetado.
